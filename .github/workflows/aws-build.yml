name: AWS Build

on: 
  workflow_call:
    inputs: 
      trigger_type:
        required: true
        type: string
      stage:
        required: false
        type: string
      runner:
        required: false
        type: string
        default: 'ubuntu-latest'
      notifications:
        required: false
        type: boolean
        default: true
        description: "Enable notifications to cloud or team owner flag"
      infra_templates_version:
        required: false
        type: string
        default: master
        description: "Infra template version for get all configuration files"
      force_build:
        required: false
        type: boolean
        default: false
        description: "Force a codebuild pipeline run"
      branching_mode:
        required: false
        type: string
        default: gitflow
        description: "Repository branching strategy"

    outputs:
      new_stage:
        description: "New stage deployment check flag"
        value: ${{ jobs.check-stage.outputs.new_stage }}
      env_check:
        description: "Environment status checker"
        value: ${{ jobs.docker-build-push.outputs.env_check }}
      stage_check:
        description: "Stage status checker"
        value: ${{ jobs.check-stage.outputs.stage_check }}
      stage:
        description: "Stage name for infrastructure deployment"
        value: ${{ jobs.sets-variables.outputs.STAGE }}
      release_version:
        description: "Semantic versioning for production environment"
        value: ${{ jobs.docker-build-push.outputs.release_version }}
    
    secrets: 
      CICD_AWS_ACCESS_KEY_ID:
        required: true
      CICD_AWS_SECRET_ACCESS_KEY:
        required: true
      CICD_AWS_REGION:
        required: true
      INFRA_AWS_ACCESS_KEY_ID:
        required: true
      INFRA_AWS_SECRET_ACCESS_KEY:
        required: true
      INFRA_AWS_REGION:
        required: true
      SHARED_AWS_ACCESS_KEY_ID:
        required: true
      SHARED_AWS_SECRET_ACCESS_KEY:
        required: true
      SHARED_AWS_REGION:
        required: true
      GOOGLE_WEBHOOK:
        required: true
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_PASSWORD:
        required: false
      ACTIONS_TOKEN:
        required: true
        description: "Personal Access Token para acceder a repositorios privados"
      NPM_TOKEN:
        required: true
        description: "Private NPM token"

env:
  NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

jobs:

  sets-variables:
    runs-on: ${{ inputs.runner }}
    environment:
      name: ${{ inputs.stage }}
    name: Sets Variables
    outputs:
      COMMIT_HASH: ${{ steps.get-commit-ids.outputs.COMMIT_HASH }}
      SHORT_COMMIT_HASH: ${{ steps.get-commit-ids.outputs.SHORT_COMMIT_HASH }}
      RELEASE_TAG: ${{ steps.version-tag.outputs.RELEASE_TAG }}
      ENVIRONMENT: ${{ steps.stage.outputs.ENVIRONMENT }}
      STAGE: ${{ steps.stage.outputs.STAGE }}
      STAGE_SHORT: ${{ steps.stage.outputs.STAGE_SHORT }}
      SERVICE_NAME: ${{ steps.set-project-name.outputs.SERVICE_NAME }}
      SERVICE_TYPE: ${{ steps.set-project-name.outputs.SERVICE_TYPE }}
      PROJECT: ${{ steps.set-project-name.outputs.PROJECT }}
    steps:   
      - name: Check Inputs
        id: check-inputs
        run: |
          echo "Checking job inputs...."
          echo "trigger_type: ${{inputs.trigger_type}}"
          echo "input stage: ${{inputs.stage}}"
          echo "runner: ${{inputs.runner}}"
          echo "notifications: ${{inputs.notifications}}"
          echo "is prerelease: " ${{github.event.release.prerelease}}

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup AWS CLI
        run: |
          if command -v aws &> /dev/null; then
              echo "✓ AWS CLI ya instalado"
              aws --version
          else
              echo "✗ AWS CLI no encontrado. Instalando..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
              echo "✓ AWS CLI instalado"
              aws --version
          fi

      - id: install-aws-cli
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64
          
      - name: Configure AWS Credentials - INFRA
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.INFRA_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.INFRA_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.INFRA_AWS_REGION }}

      - name: Sync infra config 
        id: sync-infra-config
        run: |
          aws s3 cp s3://cor-infra-us-east-2-services-configs/${{ github.repository }}.json .infra/infra-config.json
          ls -la .infra/
          cat .infra/infra-config.json

      - name: Get Commit Hash
        id: get-commit-ids
        run: |
          echo "COMMIT_HASH=${{ github.sha }}" >> $GITHUB_ENV
          echo "COMMIT_HASH=${{ github.sha }}" >> $GITHUB_OUTPUT

          short_commit_hash=$(echo ${{ github.sha }} | cut -c 1-7)
          echo "SHORT_COMMIT_HASH=$short_commit_hash" >> $GITHUB_ENV
          echo "SHORT_COMMIT_HASH=$short_commit_hash" >> $GITHUB_OUTPUT

          echo "Commit Hash: ${{env.COMMIT_HASH}}"
          echo "Short Commit Hash: ${{env.SHORT_COMMIT_HASH}}"

      - name: Get version tag
        continue-on-error: true
        id: version-tag
        run: |
          echo "RELEASE_TAG=null" >> $GITHUB_ENV
          echo "RELEASE_TAG=null" >> $GITHUB_OUTPUT
          tag=$(git describe --exact-match --tags HEAD)
          if [[ -n "$tag" ]]; then
              echo "Current commit has a tag: $tag"
              echo "RELEASE_TAG=$tag"
              echo "RELEASE_TAG=$tag" >> $GITHUB_ENV
              echo "RELEASE_TAG=$tag" >> $GITHUB_OUTPUT
              echo "RELEASE_VERSION=$tag" >> $GITHUB_ENV
              echo "RELEASE_VERSION=$tag" >> $GITHUB_OUTPUT
          else
              echo "Current commit does not have a tag"
          fi

      - name: Get stage
        id: stage
        env:
          STAGE_INPUT: ${{ inputs.stage }}
        run: |
          if [[ -z "$STAGE_INPUT" ]]; then
            echo "STAGE_INPUT is empty. Defaulting to prod."
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
            if [[ "${{ github.event_name }}" == 'release' && "${{ github.event.release.prerelease }}" == true ]]; then
              echo "This is a pre-release."
              echo "STAGE=beta" >> $GITHUB_ENV
              echo "STAGE=beta" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_ENV
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_OUTPUT
              elif [[ "${{ github.event_name }}" == 'release' ]]; then
              echo "This is a full release."
              echo "STAGE=production" >> $GITHUB_ENV
              echo "STAGE=production" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_ENV
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_OUTPUT
            fi
          else
            if [[ "$STAGE_INPUT" =~ ^staging([1-9]|10)?$ ]]; then
              STAGE=${STAGE_INPUT/staging/}
              echo "ENVIRONMENT=staging" >> $GITHUB_ENV
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_ENV
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=st$STAGE" >> $GITHUB_ENV
              echo "STAGE_SHORT=st$STAGE" >> $GITHUB_OUTPUT
              echo "Se está ejecutando como staging"
            else
              echo "Invalid STAGE_INPUT format. Defaulting to prod."
              echo "ENVIRONMENT=prod" >> $GITHUB_ENV
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_ENV
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_ENV
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Extract branch name - Trunk Mode
        id: extract_branch_trunk
        if: contains( inputs.branching_mode, 'trunk' )
        shell: bash
        run: |
          echo "BRANCH_NAME=$GITHUB_REF_NAME" 
          echo "BRANCH_NAME=$GITHUB_REF_NAME" >> $GITHUB_ENV 
          echo "BRANCH_NAME=$GITHUB_REF_NAME" >> $GITHUB_OUTPUT 

      - name: Extract branch name - Gitflow Mode
        id: extract_branch
        if: contains(fromJson('["push", "release", "pull_request"]'), github.event_name)
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == 'pull_request' ]]; then
            BRANCH_NAME=${{github.base_ref}}
            echo "Branch name extracted from pull request: $BRANCH_NAME"
            echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          elif [[ "${{ github.event_name }}" == 'release' && "${{ github.event.release.prerelease }}" == true ]]; then
            echo "This is a pre-release."
            BRANCH_NAME="beta"
            echo "BRANCH_NAME=beta" >> $GITHUB_ENV
          elif [[ "${{ github.event_name }}" == 'release' ]]; then
            echo "This is a full release."
            BRANCH_NAME="master"
            echo "BRANCH_NAME=master" >> $GITHUB_ENV
          fi
          echo "Extracted branch name: $BRANCH_NAME"

      - name: Set release/branch version - staging
        id: set-release-staging
        if: contains(fromJson('["workflow_dispatch"]'), inputs.trigger_type)
        run: |
          RELEASE_VERSION=${{ inputs.stage }}
          RELEASE_VERSION=$(echo $RELEASE_VERSION | sed s/staging/v/g)
          RELEASE_VERSION=$RELEASE_VERSION".0.0-staging-"${{ env.SHORT_COMMIT_HASH}}
          echo "Final staging release version: "$RELEASE_VERSION
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "BRANCH_NAME=${GITHUB_REF#refs/*/}" >> $GITHUB_ENV

      - name: Get service info from config
        id: set-project-name
        shell: bash
        run: |
          SERVICE_NAME=$(jq -r '.name' .infra/infra-config.json)
          SERVICE_TYPE=$(jq -r '.type // "service"' .infra/infra-config.json)
          
          echo "SERVICE_NAME=$SERVICE_NAME"
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT
          
          echo "SERVICE_TYPE=$SERVICE_TYPE"
          echo "SERVICE_TYPE=$SERVICE_TYPE" >> $GITHUB_ENV
          echo "SERVICE_TYPE=$SERVICE_TYPE" >> $GITHUB_OUTPUT
          
          echo "PROJECT=$(echo $SERVICE_NAME-${{ env.STAGE }})"
          echo "PROJECT=$(echo $SERVICE_NAME-${{ env.STAGE }})" >> $GITHUB_ENV
          echo "PROJECT=$(echo $SERVICE_NAME-${{ env.STAGE }})" >> $GITHUB_OUTPUT

  check-stage:
    runs-on: ${{ inputs.runner }}
    environment:
      name: ${{ inputs.stage }}
    name: Check Stage Configuration
    needs: sets-variables
    outputs:
      new_stage: ${{ steps.check-stage-config.outputs.new_stage }}
      stage_check: ${{ steps.check-stage-config.outputs.stage_check }}
      
    steps:
      - id: install-aws-cli
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64

      - name: Configure AWS Credentials - INFRA
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.INFRA_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.INFRA_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.INFRA_AWS_REGION }}

      - name: Check if stage configuration exists
        id: check-stage-config
        shell: bash
        run: |
          # Verificar si existe la configuración para este stage
          CONFIG_EXISTS=$(aws s3 ls s3://cor-infra-us-east-2-services-configs/${{ github.repository }}.json 2>/dev/null || echo "false")
          
          if [[ "$CONFIG_EXISTS" == "false" ]]; then
            echo "new_stage=true"
            echo "new_stage=true" >> $GITHUB_OUTPUT
            echo "stage_check=false"
            echo "stage_check=false" >> $GITHUB_OUTPUT
          else
            echo "new_stage=false"
            echo "new_stage=false" >> $GITHUB_OUTPUT
            echo "stage_check=true"
            echo "stage_check=true" >> $GITHUB_OUTPUT
          fi

  docker-build-push:
    runs-on: ${{ inputs.runner }}
    environment:
      name: ${{ inputs.stage }}    
    name: Docker Build and Push to ECR
    needs: [sets-variables, check-stage]
    outputs:
      release_version: ${{ steps.set-release-version.outputs.RELEASE_VERSION }}
      env_check: ${{ steps.build-complete.outputs.env_check }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Checkout Infra Templates
        uses: actions/checkout@v4
        with:
          repository: ProjectCORTeam/infra-service-templates
          ref: ${{ inputs.infra_templates_version }}
          path: infra-templates
          token: ${{ secrets.ACTIONS_TOKEN }}

      - id: install-aws-cli
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64

      - name: Set release version
        id: set-release-version
        run: |
          if [[ "${{ inputs.stage }}" =~ ^staging ]]; then
            RELEASE_VERSION=${{ inputs.stage }}
            RELEASE_VERSION=$(echo $RELEASE_VERSION | sed s/staging/v/g)
            RELEASE_VERSION=$RELEASE_VERSION".0.0-staging-"${{ needs.sets-variables.outputs.SHORT_COMMIT_HASH}}
            RUN_ENV="staging"
          elif [[ "${{ inputs.stage }}" == "production" ]] || [[ "${{ inputs.stage }}" == "beta" ]] || [[ -z "${{ inputs.stage }}" ]]; then
            RELEASE_VERSION=${{ needs.sets-variables.outputs.RELEASE_TAG }}
            RUN_ENV="prod"
          fi
          
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "RUN_ENV=$RUN_ENV" >> $GITHUB_ENV
          echo "RUN_ENV=$RUN_ENV" >> $GITHUB_OUTPUT
          echo "Final release version: $RELEASE_VERSION"
          echo "Environment: $RUN_ENV"

      - name: Configure AWS Credentials - Shared (for ECR)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.SHARED_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.SHARED_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.SHARED_AWS_REGION }}

      - name: Login to Amazon ECR
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: 'true'

      - name: Check ECR image tag
        id: check-ecr-tag
        continue-on-error: true
        run: |
          aws ecr describe-images \
            --repository-name ${{ steps.login-ecr.outputs.registry }}/cor-shared-us-east-2-${{ needs.sets-variables.outputs.SERVICE_TYPE }}-${{ needs.sets-variables.outputs.SERVICE_NAME }} \
            --region ${{ secrets.SHARED_AWS_REGION }} \
            --image-ids imageTag=${{ env.RELEASE_VERSION }}

      - name: Check ECR image tag outcome
        id: check-ecr
        run: |
          echo "ECR check outcome: ${{ steps.check-ecr-tag.outcome }}"
          if [ '${{ steps.check-ecr-tag.outcome }}' == 'failure' ]; then
            echo "Release version is not builded"
            echo "ECR_IMAGE_EXIST=false" >> $GITHUB_ENV
          elif [ '${{ steps.check-ecr-tag.outcome }}' == 'success' ]; then
            echo "Release version is already builded"
            echo "ECR_IMAGE_EXIST=true" >> $GITHUB_ENV
          fi

      - name: Run custom pre-build script
        if: (inputs.force_build || env.ECR_IMAGE_EXIST == 'false') && hashFiles('.infra/cicd/pre-build.sh') != ''
        run: |
          chmod +x .infra/cicd/pre-build.sh
          ./.infra/cicd/pre-build.sh

      - name: Set up Docker Buildx
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        uses: docker/setup-buildx-action@v3

      - name: Extract Docker metadata
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/cor-shared-us-east-2-${{ needs.sets-variables.outputs.SERVICE_TYPE }}-${{ needs.sets-variables.outputs.SERVICE_NAME }}
          tags: |
            type=raw,value=${{ env.RELEASE_VERSION }}
            type=raw,value=${{ needs.sets-variables.outputs.STAGE }}
          #  type=raw,value=${{ needs.sets-variables.outputs.STAGE }},enable=${{ env.RUN_ENV == 'prod' }}
          #  type=raw,value=latest,enable=${{ env.RUN_ENV == 'prod' && needs.sets-variables.outputs.STAGE == 'production' }}
          
      - name: Run custom build script
        if: (inputs.force_build || env.ECR_IMAGE_EXIST == 'false') && hashFiles('.infra/cicd/build.sh') != ''
        run: |
          chmod +x .infra/cicd/build.sh
          ./.infra/cicd/build.sh

      - name: Build and push Docker image
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64
          provenance: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            RELEASE_VERSION=${{ env.RELEASE_VERSION }}
            STAGE=${{ needs.sets-variables.outputs.STAGE }}
            RUN_ENV=${{ env.RUN_ENV }}
            ${{
              secrets.POETRY_HTTP_BASIC_GITHUB_USERNAME && format('POETRY_HTTP_BASIC_GITHUB_USERNAME={0}', secrets.POETRY_HTTP_BASIC_GITHUB_USERNAME) || ''
            }}
            ${{
              secrets.POETRY_HTTP_BASIC_GITHUB_PASSWORD && format('POETRY_HTTP_BASIC_GITHUB_PASSWORD={0}', secrets.POETRY_HTTP_BASIC_GITHUB_PASSWORD) || ''
            }}

      - name: Install Helm
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.4'

      - name: Setup Helm ChartMuseum
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        run: |
          helm plugin install https://github.com/chartmuseum/helm-push || true
          helm repo add cor https://chartmuseum.shared.projectcor.com
          helm repo update

      - name: Package and Push Helm Chart
        if: inputs.force_build || env.ECR_IMAGE_EXIST == 'false'
        run: |
          cd infra-templates/templates/simple-service-persistence/simple-eks/kubernetes/service/
          
          # Reemplazar variables en los templates
          find . -type f -exec sed -i 's/\$TEMPLATE_SERVICE_NAME/'"${{ needs.sets-variables.outputs.SERVICE_NAME }}"'/g' {} +
          find . -type f -exec sed -i 's/\$TEMPLATE_SERVICE_TYPE/'"${{ needs.sets-variables.outputs.SERVICE_TYPE }}"'/g' {} +
          
          # Empaquetar y pushear el chart
          helm package . --version ${{ env.RELEASE_VERSION }} --app-version ${{ env.RELEASE_VERSION }}
          helm cm-push ${{ needs.sets-variables.outputs.SERVICE_TYPE }}-${{ needs.sets-variables.outputs.SERVICE_NAME }}-${{ env.RELEASE_VERSION }}.tgz cor -f

      - name: Run custom post-build script
        if: (inputs.force_build || env.ECR_IMAGE_EXIST == 'false') && hashFiles('.infra/cicd/post-build.sh') != ''
        run: |
          chmod +x .infra/cicd/post-build.sh
          ./.infra/cicd/post-build.sh

      - name: Build complete
        id: build-complete
        run: |
          echo "env_check=success" >> $GITHUB_OUTPUT

      - name: Google Chat Notification - Build Success
        if: inputs.notifications && (inputs.force_build || env.ECR_IMAGE_EXIST == 'false')
        uses: nakamuraos/google-chat-notifications@v2.1.0
        with:
          title: Image Build Success
          subtitle: ${{ env.RELEASE_VERSION }}
          webhookUrl: ${{ secrets.GOOGLE_WEBHOOK }}
          status: 'success'

      - name: Google Chat Notification - Image Already Exists
        if: inputs.notifications && env.ECR_IMAGE_EXIST == 'true' && !inputs.force_build
        uses: nakamuraos/google-chat-notifications@v2.1.0
        with:
          title: Image Build Skipped
          subtitle: ${{ env.RELEASE_VERSION }} already exists
          webhookUrl: ${{ secrets.GOOGLE_WEBHOOK }}
          status: 'success'

      - name: Output summary
        run: |
          echo "### Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Service:** ${{ needs.sets-variables.outputs.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Stage:** ${{ needs.sets-variables.outputs.STAGE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Version:** ${{ env.RELEASE_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ env.RUN_ENV }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECR Repository:** ${{ needs.sets-variables.outputs.ECR_REPOSITORY }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Already Exists:** ${{ env.ECR_IMAGE_EXIST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Forced:** ${{ inputs.force_build }}" >> $GITHUB_STEP_SUMMARY
