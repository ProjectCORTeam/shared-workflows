name: AWS Build (Optimized)

on: 
  workflow_call:
    inputs: 
      trigger_type:
        required: true
        type: string
      stage:
        required: false
        type: string
      runner:
        required: false
        type: string
        default: 'ubuntu-latest'
      notifications:
        required: false
        type: boolean
        default: true
        description: "Enable notifications to cloud or team owner flag"
      infra_templates_version:
        required: false
        type: string
        default: master
        description: "Infra template version for get all configuration files"
      force_build:
        required: false
        type: boolean
        default: false
        description: "Force a codebuild pipeline run"
      branching_mode:
        required: false
        type: string
        default: gitflow
        description: "Repository branching strategy"

    outputs:
      new_stage:
        description: "New stage deployment check flag"
        value: ${{ jobs.check-stage.outputs.new_stage }}
      env_check:
        description: "Environment status checker"
        value: ${{ jobs.docker-build-push.outputs.env_check }}
      stage_check:
        description: "Stage status checker"
        value: ${{ jobs.check-stage.outputs.stage_check }}
      stage:
        description: "Stage name for infrastructure deployment"
        value: ${{ jobs.sets-variables.outputs.STAGE }}
      release_version:
        description: "Semantic versioning for production environment"
        value: ${{ jobs.docker-build-push.outputs.release_version }}
    
    secrets: 
      CICD_AWS_ACCESS_KEY_ID:
        required: true
      CICD_AWS_SECRET_ACCESS_KEY:
        required: true
      CICD_AWS_REGION:
        required: true
      INFRA_AWS_ACCESS_KEY_ID:
        required: true
      INFRA_AWS_SECRET_ACCESS_KEY:
        required: true
      INFRA_AWS_REGION:
        required: true
      SHARED_AWS_ACCESS_KEY_ID:
        required: true
      SHARED_AWS_SECRET_ACCESS_KEY:
        required: true
      SHARED_AWS_REGION:
        required: true
      GOOGLE_WEBHOOK:
        required: true
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_PASSWORD:
        required: false
      GH_PAT:
        required: true
        description: "Personal Access Token para acceder a repositorios privados"

jobs:

  sets-variables:
    runs-on: ${{ inputs.runner }}
    name: Sets Variables
    outputs:
      COMMIT_HASH: ${{ steps.get-commit-ids.outputs.COMMIT_HASH }}
      SHORT_COMMIT_HASH: ${{ steps.get-commit-ids.outputs.SHORT_COMMIT_HASH }}
      RELEASE_TAG: ${{ steps.version-tag.outputs.RELEASE_TAG }}
      ENVIRONMENT: ${{ steps.stage.outputs.ENVIRONMENT }}
      STAGE: ${{ steps.stage.outputs.STAGE }}
      STAGE_SHORT: ${{ steps.stage.outputs.STAGE_SHORT }}
      SERVICE_NAME: ${{ steps.set-project-name.outputs.SERVICE_NAME }}
      SERVICE_TYPE: ${{ steps.set-project-name.outputs.SERVICE_TYPE }}
      PROJECT: ${{ steps.set-project-name.outputs.PROJECT }}
      ECR_REPOSITORY: ${{ steps.set-project-name.outputs.ECR_REPOSITORY }}
    steps:   

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Cache AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/aws
          key: aws-cli-v2-${{ runner.os }}

      - name: Install AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64
          
      - name: Configure AWS Credentials - INFRA
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.INFRA_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.INFRA_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.INFRA_AWS_REGION }}

      - name: Sync infra config 
        run: |
          aws s3 cp s3://cor-infra-us-east-2-services-configs/${{ github.repository }}.json .infra/infra-config.json

      - name: Get Commit Hash & Service Info
        id: get-commit-ids
        run: |
          SHORT_COMMIT_HASH=$(echo ${{ github.sha }} | cut -c 1-7)
          echo "COMMIT_HASH=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "SHORT_COMMIT_HASH=$SHORT_COMMIT_HASH" >> $GITHUB_OUTPUT

      - name: Get version tag
        continue-on-error: true
        id: version-tag
        run: |
          tag=$(git describe --exact-match --tags HEAD 2>/dev/null || echo "null")
          echo "RELEASE_TAG=$tag" >> $GITHUB_OUTPUT

      - name: Get stage
        id: stage
        env:
          STAGE_INPUT: ${{ inputs.stage }}
        run: |
          if [[ -z "$STAGE_INPUT" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_OUTPUT
            if [[ "${{ github.event_name }}" == 'release' && "${{ github.event.release.prerelease }}" == true ]]; then
              echo "STAGE=beta" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=beta" >> $GITHUB_OUTPUT
            else
              echo "STAGE=production" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=prod" >> $GITHUB_OUTPUT
            fi
          else
            if [[ "$STAGE_INPUT" =~ ^staging([1-9]|10)?$ ]]; then
              STAGE=${STAGE_INPUT/staging/}
              echo "ENVIRONMENT=staging" >> $GITHUB_OUTPUT
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=st$STAGE" >> $GITHUB_OUTPUT
            else
              echo "ENVIRONMENT=prod" >> $GITHUB_OUTPUT
              echo "STAGE=$STAGE_INPUT" >> $GITHUB_OUTPUT
              echo "STAGE_SHORT=$STAGE_INPUT" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Get service info from config
        id: set-project-name
        run: |
          SERVICE_NAME=$(jq -r '.name' .infra/infra-config.json)
          SERVICE_TYPE=$(jq -r '.type // "service"' .infra/infra-config.json)
          
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "SERVICE_TYPE=$SERVICE_TYPE" >> $GITHUB_OUTPUT
          echo "PROJECT=$SERVICE_NAME-${{ steps.stage.outputs.STAGE }}" >> $GITHUB_OUTPUT
          echo "ECR_REPOSITORY=cor-shared-us-east-2-$SERVICE_TYPE-$SERVICE_NAME" >> $GITHUB_OUTPUT

  check-stage:
    runs-on: ${{ inputs.runner }}
    name: Check Stage Configuration
    needs: sets-variables
    outputs:
      new_stage: ${{ steps.check-stage-config.outputs.new_stage }}
      stage_check: ${{ steps.check-stage-config.outputs.stage_check }}
      
    steps:
      - name: Cache AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/aws
          key: aws-cli-v2-${{ runner.os }}

      - name: Install AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64

      - name: Configure AWS Credentials - INFRA
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.INFRA_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.INFRA_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.INFRA_AWS_REGION }}

      - name: Check if stage configuration exists
        id: check-stage-config
        run: |
          CONFIG_EXISTS=$(aws s3 ls s3://cor-infra-us-east-2-services-configs/${{ github.repository }}-${{ needs.sets-variables.outputs.STAGE }}.json 2>/dev/null || echo "false")
          
          if [[ "$CONFIG_EXISTS" == "false" ]]; then
            echo "new_stage=true" >> $GITHUB_OUTPUT
            echo "stage_check=false" >> $GITHUB_OUTPUT
          else
            echo "new_stage=false" >> $GITHUB_OUTPUT
            echo "stage_check=true" >> $GITHUB_OUTPUT
          fi

  docker-build-push:
    runs-on: ${{ inputs.runner }}
    name: Docker Build and Push to ECR
    needs: [sets-variables, check-stage]
    outputs:
      release_version: ${{ steps.set-release-version.outputs.RELEASE_VERSION }}
      env_check: ${{ steps.build-complete.outputs.env_check }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Checkout Infra Templates
        uses: actions/checkout@v4
        with:
          repository: ProjectCORTeam/infra-service-templates
          ref: ${{ inputs.infra_templates_version }}
          path: infra-templates
          token: ${{ secrets.GH_PAT }}

      - name: Cache AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/aws
          key: aws-cli-v2-${{ runner.os }}

      - name: Install AWS CLI
        if: contains( inputs.runner, 'k8s-runners-stg' )
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          verbose: false
          arch: amd64

      - name: Set release version
        id: set-release-version
        run: |
          if [[ "${{ inputs.stage }}" =~ ^staging ]]; then
            RELEASE_VERSION=$(echo "${{ inputs.stage }}" | sed s/staging/v/g).0.0-staging-${{ needs.sets-variables.outputs.SHORT_COMMIT_HASH}}
            RUN_ENV="staging"
          else
            RELEASE_VERSION=${{ needs.sets-variables.outputs.RELEASE_TAG }}
            RUN_ENV="prod"
          fi
          
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "RUN_ENV=$RUN_ENV" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials - Shared (for ECR)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.SHARED_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.SHARED_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.SHARED_AWS_REGION }}

      - name: Create ECR repository if not exists
        continue-on-error: true
        run: |
          aws ecr create-repository --repository-name ${{ needs.sets-variables.outputs.ECR_REPOSITORY }} --region ${{ secrets.SHARED_AWS_REGION }} 2>/dev/null || true

      - name: Check ECR image tag
        id: check-ecr-tag
        continue-on-error: true
        run: |
          aws ecr describe-images \
            --repository-name ${{ needs.sets-variables.outputs.ECR_REPOSITORY }} \
            --region ${{ secrets.SHARED_AWS_REGION }} \
            --image-ids imageTag=${{ steps.set-release-version.outputs.RELEASE_VERSION }}

      - name: Run custom pre-build script
        if: (inputs.force_build || steps.check-ecr-tag.outcome == 'failure') && hashFiles('.infra/cicd/pre-build.sh') != ''
        run: |
          chmod +x .infra/cicd/pre-build.sh
          ./.infra/cicd/pre-build.sh

      - name: Login to Amazon ECR
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: 'true'

      - name: Set up Docker Buildx
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        uses: docker/setup-buildx-action@v3

      - name: Run custom build script
        if: (inputs.force_build || steps.check-ecr-tag.outcome == 'failure') && hashFiles('.infra/cicd/build.sh') != ''
        run: |
          chmod +x .infra/cicd/build.sh
          ./.infra/cicd/build.sh

      - name: Build and push Docker image
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64
          provenance: false
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ needs.sets-variables.outputs.ECR_REPOSITORY }}:${{ steps.set-release-version.outputs.RELEASE_VERSION }}
            ${{ steps.login-ecr.outputs.registry }}/${{ needs.sets-variables.outputs.ECR_REPOSITORY }}:${{ needs.sets-variables.outputs.STAGE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            RELEASE_VERSION=${{ steps.set-release-version.outputs.RELEASE_VERSION }}
            STAGE=${{ needs.sets-variables.outputs.STAGE }}
            RUN_ENV=${{ steps.set-release-version.outputs.RUN_ENV }}

      - name: Cache Helm
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/helm
            ~/.local/share/helm
          key: helm-${{ runner.os }}-v3.14.4

      - name: Install Helm
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.4'

      - name: Setup Helm ChartMuseum
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        run: |
          helm plugin list | grep -q cm-push || helm plugin install https://github.com/chartmuseum/helm-push
          helm repo list | grep -q "^cor\s" || helm repo add cor https://chartmuseum.shared.projectcor.com
          helm repo update cor

      - name: Package and Push Helm Chart
        if: inputs.force_build || steps.check-ecr-tag.outcome == 'failure'
        run: |
          cd infra-templates/templates/simple-service-persistence/simple-eks/kubernetes/service/
          
          # Reemplazar variables en los templates
          find . -type f -exec sed -i 's/\$TEMPLATE_SERVICE_NAME/'"${{ needs.sets-variables.outputs.SERVICE_NAME }}"'/g' {} +
          find . -type f -exec sed -i 's/\$TEMPLATE_SERVICE_TYPE/'"${{ needs.sets-variables.outputs.SERVICE_TYPE }}"'/g' {} +
          
          # Empaquetar y pushear el chart
          helm package . --version ${{ steps.set-release-version.outputs.RELEASE_VERSION }} --app-version ${{ steps.set-release-version.outputs.RELEASE_VERSION }}
          helm cm-push ${{ needs.sets-variables.outputs.SERVICE_TYPE }}-${{ needs.sets-variables.outputs.SERVICE_NAME }}-${{ steps.set-release-version.outputs.RELEASE_VERSION }}.tgz cor -f

      - name: Run custom post-build script
        if: (inputs.force_build || steps.check-ecr-tag.outcome == 'failure') && hashFiles('.infra/cicd/post-build.sh') != ''
        run: |
          chmod +x .infra/cicd/post-build.sh
          ./.infra/cicd/post-build.sh

      - name: Build complete
        id: build-complete
        run: |
          echo "env_check=success" >> $GITHUB_OUTPUT

      - name: Google Chat Notification - Build Success
        if: inputs.notifications && (inputs.force_build || steps.check-ecr-tag.outcome == 'failure')
        uses: nakamuraos/google-chat-notifications@v2.1.0
        with:
          title: Image Build Success
          subtitle: ${{ steps.set-release-version.outputs.RELEASE_VERSION }}
          webhookUrl: ${{ secrets.GOOGLE_WEBHOOK }}
          status: 'success'

      - name: Google Chat Notification - Image Already Exists
        if: inputs.notifications && steps.check-ecr-tag.outcome == 'success' && !inputs.force_build
        uses: nakamuraos/google-chat-notifications@v2.1.0
        with:
          title: Image Build Skipped
          subtitle: ${{ steps.set-release-version.outputs.RELEASE_VERSION }} already exists
          webhookUrl: ${{ secrets.GOOGLE_WEBHOOK }}
          status: 'success'

